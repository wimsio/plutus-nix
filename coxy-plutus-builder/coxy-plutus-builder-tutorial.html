<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Coxy Haskell Plutus Builder (CHPB) ‚Äì Tutorial</title>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background-color: #f5f5f7;
      margin: 0;
      padding: 0;
      color: #222;
    }

    .container {
      max-width: 960px;
      margin: 40px auto;
      padding: 40px;
      background-color: #ffffff;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.06);
      border-radius: 12px;
    }

    header {
      text-align: center;
      margin-bottom: 40px;
    }

    header h1 {
      font-size: 1.9rem;
      margin: 0 0 10px;
    }

    header p {
      margin: 2px 0;
      font-size: 0.95rem;
    }

    header .meta {
      margin-top: 8px;
      font-size: 0.9rem;
      color: #555;
    }

    h2 {
      margin-top: 32px;
      margin-bottom: 12px;
      font-size: 1.25rem;
    }

    h3 {
      margin-top: 20px;
      margin-bottom: 8px;
      font-size: 1.05rem;
    }

    p {
      font-size: 0.98rem;
      line-height: 1.6;
      text-align: justify;
      margin: 0 0 14px;
    }

    #toc {
      margin-bottom: 32px;
      padding: 16px 20px;
      background-color: #f0f2f5;
      border-radius: 10px;
    }

    #toc h2 {
      margin-top: 0;
      font-size: 1.15rem;
    }

    #toc ol {
      padding-left: 20px;
      margin: 10px 0 0;
      font-size: 0.96rem;
    }

    #toc a {
      text-decoration: none;
      color: #1f5fbf;
    }

    #toc a:hover {
      text-decoration: underline;
    }

    .glossary-term {
      font-weight: 600;
      margin-top: 14px;
      margin-bottom: 4px;
    }

    .divider {
      margin: 40px 0 20px;
      border: none;
      border-top: 1px solid #ddd;
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Title : Coxy Haskell Plutus Builder (CHPB)</h1>
      <p><strong>Company</strong> : Coxygen Global (Pty) Ltd</p>
      <p class="meta"><strong>Author</strong> : Bernard Sibanda</p>
      <p class="meta"><strong>Date</strong> : 20 November 2025</p>
    </header>

    <!-- Table of Contents -->
    <nav id="toc">
      <h2>Table of Contents</h2>
      <ol>
        <li><a href="#section-1">üìò Introduction to Coxy Haskell Plutus Builder</a></li>
        <li><a href="#section-2">üß≠ Core Concepts: Industries, Datum, Redeemer and Constraints</a></li>
        <li><a href="#section-3">üñ•Ô∏è Getting Started with the CHPB Interface</a></li>
        <li><a href="#section-4">üîç Searching and Selecting a Smart Contract Industry</a></li>
        <li><a href="#section-5">üß± Working with Template Industries</a></li>
        <li><a href="#section-6">üßÆ Configuring Coxy Datum and Custom Datum Fields</a></li>
        <li><a href="#section-7">üéõÔ∏è Configuring Coxy Redeemer and Action Constraints</a></li>
        <li><a href="#section-8">üß© Using Parameter Datum (CoxyParamDatum)</a></li>
        <li><a href="#section-9">üß™ Creating a Custom Smart Contract Industry</a></li>
        <li><a href="#section-10">‚öôÔ∏è Generating JSON Specifications and Haskell Code</a></li>
        <li><a href="#section-11">üìÇ Downloading and Integrating ValidatorLogic.hs</a></li>
        <li><a href="#section-12">üß∑ End-to-End Example: Coxy / Marketplace Escrow</a></li>
        <li><a href="#section-13">üõ†Ô∏è Troubleshooting and Practical Tips</a></li>
        <li><a href="#section-14">üìö Glossary of Terms</a></li>
      </ol>
    </nav>

    <main>
      <!-- 1 -->
      <section id="section-1">
        <h2>1. üìò Introduction to Coxy Haskell Plutus Builder</h2>
        <p>
          Coxy Haskell Plutus Builder (CHPB) is an interactive web-based tool that helps you design Plutus validator
          logic without manually wiring every data type and constraint from scratch. It provides a curated library of
          ‚Äúindustries‚Äù, such as marketplaces, auctions, automated market makers and credit primitives, each with
          pre-defined datum fields, redeemer actions and safety constraints. From a single screen, you can select the
          industry you want, choose the data you care about, enable or disable constraints and then generate
          machine-readable JSON specifications together with a ready-to-integrate Haskell module containing your
          validator skeleton and associated types.
        </p>
        <p>
          CHPB offers two main modes of use. The first mode is template-based, where you simply pick one of the
          pre-packaged industries, such as ‚ÄúCoxy / Marketplace‚Äù, ‚ÄúMembership SBT / DAO‚Äù or ‚ÄúStable-swap AMM
          (Curve-like)‚Äù, and specialise it by ticking fields and constraints. The second mode is fully custom, where you
          define your own contract title, datum type, redeemer type, datum fields and actions from scratch in a guided
          way, while still benefiting from the same export pipeline to JSON and Haskell code. In both modes, the tool
          helps you move from conceptual design to concrete validator logic in a structured and repeatable way.
        </p>
      </section>

      <!-- 2 -->
      <section id="section-2">
        <h2>2. üß≠ Core Concepts: Industries, Datum, Redeemer and Constraints</h2>
        <p>
          In CHPB, an ‚Äúindustry‚Äù represents a reusable contract archetype for a particular DeFi or Web3 use case. Each
          industry describes a datum type name, a redeemer type name, a list of datum fields, a list of redeemer actions
          and a set of constraints that can be attached to each action. For example, a marketplace industry might define
          a datum type with fields such as seller, buyer, amount and deadline, and a redeemer type with actions like
          paying the seller or refunding the buyer. This structure allows you to think of an industry as a high-level
          template from which concrete contracts are derived.
        </p>
        <p>
          A datum field is a typed on-chain value that describes the state of a contract instance, such as the seller‚Äôs
          public key hash or an auction deadline. Redeemer actions represent user-triggered events or flows, such as
          joining a DAO, placing a bid or executing a time-weighted order. Constraints are named logical conditions
          which will be checked in the final validator, for example that a transaction is signed by a specific party or
          that a computed price is correct. In CHPB you bind constraints to actions using simple checkboxes, and the
          builder later converts this selection into Haskell checks in the validator function.
        </p>
      </section>

      <!-- 3 -->
      <section id="section-3">
        <h2>3. üñ•Ô∏è Getting Started with the CHPB Interface</h2>
        <p>
          The CHPB interface is a single-page layout with a header, a three-step top row, configuration panels for datum
          and redeemer, a preview area and an output section for JSON and Haskell code. The layout is styled with a
          modern card-based design and rounded buttons so that each logical block of the workflow is visually
          separated. At the very top you will see the title ‚ÄúCoxy Haskell Plutus Builder‚Äù, which introduces the page as
          the main playground for your contract design session.
        </p>
        <p>
          Below the header, the interface walks you through a natural workflow. First you search or select an industry,
          then you adjust datum and redeemer settings, optionally configure parameter datum fields and finally you click
          ‚ÄúGenerate Logic Spec‚Äù to populate the JSON and Haskell output areas. A dedicated ‚ÄúDownload ValidatorLogic.hs‚Äù
          button allows you to export the generated module as a file which you can drop directly into your Haskell
          project. This step-by-step layout makes it easy for both new and experienced users to follow the same clear
          process from idea to implementation.
        </p>
      </section>

      <!-- 4 -->
      <section id="section-4">
        <h2>4. üîç Searching and Selecting a Smart Contract Industry</h2>
        <p>
          The first row of CHPB contains three blocks that guide how you select or define your contract. The left block
          contains a search input labelled ‚Äú1. Search Smart Contract Or Industry‚Äù. This search box filters the available
          industries by both their identifier and their label as you type, so you can quickly narrow down to examples
          such as auctions, stable-swap pools or membership contracts by entering any part of the industry name.
        </p>
        <p>
          The middle block is titled ‚Äú2. Smart Contract Industry‚Äù and presents a dropdown that lists all industries
          currently defined in the configuration. When the page loads, CHPB populates this dropdown and automatically
          selects the first industry in the list, rendering its datum fields and actions below. Whenever you change the
          selection, the builder re-renders the datum and action panels and clears previously generated outputs so that
          your JSON and Haskell code always match the currently selected industry.
        </p>
        <p>
          The right block is titled ‚Äú3. Create Custom Smart Contract‚Äù and introduces the custom mode toggle. When you
          enable this toggle, CHPB hides the standard template panels, disables the industry dropdown and search box and
          reveals a dedicated area for defining your own industry. In that area you can specify your contract title,
          datum type, redeemer type, datum fields and actions from scratch, giving you full control over the final
          design.
        </p>
      </section>

      <!-- 5 -->
      <section id="section-5">
        <h2>5. üß± Working with Template Industries</h2>
        <p>
          In template mode, CHPB uses predefined industries as blueprints. Each template describes the structure of the
          datum, the available actions and the default constraints for those actions. For example, a membership industry
          can define a datum with fields such as the organisation, member identity, join time, expiry and level, and
          actions like joining, renewing and revoking membership. Similarly, a stable-swap industry can define a pool
          datum with amplification and fee parameters, and actions such as swapping, adding liquidity and removing
          liquidity.
        </p>
        <p>
          When you select a template industry, CHPB renders a labelled checkbox for every datum field in that industry
          in the ‚ÄúCoxy Datum‚Äù panel. You decide which fields you want to include in your specialised contract by
          ticking their checkboxes. For the actions, CHPB renders blocks in the ‚ÄúCoxy Redeemer‚Äù panel, one block per
          action, each containing constraint checkboxes that are pre-checked according to the industry defaults. In this
          way, the template industries give you a rich starting point while leaving you free to simplify or tighten the
          logic as needed.
        </p>
      </section>

      <!-- 6 -->
      <section id="section-6">
        <h2>6. üßÆ Configuring Coxy Datum and Custom Datum Fields</h2>
        <p>
          The ‚ÄúCoxy Datum‚Äù panel is where you configure the on-chain datum type for your contract. Initially, the panel
          shows the template datum fields as a list of labelled checkboxes, such as a seller public key hash or a
          deadline time. When you generate the logic specification, CHPB takes only the checked fields and includes them
          in the final datum specification, preserving the type information for each field so that your Haskell code
          remains strongly typed and self-documenting.
        </p>
        <p>
          Below the template fields there is a toggle labelled ‚ÄúEnable Custom Datum Fields (advanced users)‚Äù. When you
          enable this toggle, a sub-section appears that allows you to add arbitrary extra datum fields using text
          inputs and a type dropdown. The dropdown is pre-populated with a canonical list of Plutus types, such as
          integers, booleans, public key hashes, times, values and currency symbols. Each row you add contributes a
          custom field entry to the datum specification containing a name and a type. This mechanism is useful when your
          desired contract is mostly covered by a template but requires one or two project-specific fields that are not
          part of the base industry.
        </p>
      </section>

      <!-- 7 -->
      <section id="section-7">
        <h2>7. üéõÔ∏è Configuring Coxy Redeemer and Action Constraints</h2>
        <p>
          The ‚ÄúCoxy Redeemer‚Äù panel is where you shape the behaviour of the contract by configuring which constraints
          apply to each redeemer action. For every action defined by the selected industry, CHPB renders a compact card
          that shows the action‚Äôs label at the top and then lists all available constraints with checkboxes. Each
          checkbox expresses whether the corresponding condition should be enforced when that action is used at
          validation time. For example, a ‚ÄúPaySeller‚Äù action may include constraints that verify that the script holds a
          particular NFT, that the transaction is signed by the buyer and that the seller is actually paid.
        </p>
        <p>
          When you click ‚ÄúGenerate Logic Spec‚Äù, CHPB reads the checked constraints for each action and constructs a
          redeemer specification. For template industries, each action entry in the redeemer specification has an
          identifier, a human-readable label and a list of selected constraints. This specification is later used to
          generate the Haskell validator, where each action pattern is followed by a chain of checks that mirror the
          constraints you chose in the user interface.
        </p>
        <p>
          A second toggle, labelled ‚ÄúEnable Custom Redeemer Actions (advanced users)‚Äù, allows you to define additional
          actions that are not part of the industry template. When you enable this toggle, you can add rows containing
          an action name and an optional description. These custom actions are captured in a dedicated list on the
          redeemer specification and appear in the Haskell preview as extra case branches. Each branch uses a simple
          guard that you can later refine with your own custom logic in the final Plutus code.
        </p>
      </section>

      <!-- 8 -->
      <section id="section-8">
        <h2>8. üß© Using Parameter Datum (CoxyParamDatum)</h2>
        <p>
          Beyond the primary datum type, CHPB supports an optional parameter datum type called CoxyParamDatum. The
          purpose of this parameter datum is to model contract-level parameters that are fixed at script instantiation
          time but are not meant to vary between UTxOs. Examples include protocol fees, fixed beneficiaries or
          governance addresses. In the ‚ÄúCoxy Datum‚Äù panel you will find a separate toggle labelled ‚ÄúGenerate parameter
          datum type (CoxyParamDatum)‚Äù. When enabled, the validator type changes to include this parameter datum as an
          additional argument.
        </p>
        <p>
          Each parameter row consists of a field name and a Haskell type, both captured through text inputs with type
          options built from the same Plutus type list used in other parts of the tool. When you generate the
          specification, CHPB builds a parameter datum specification containing an array of fields. If you enable the
          parameter datum but provide no fields, the tool warns you and cancels generation to avoid creating an
          inconsistent type. In the Haskell preview, the parameter datum name appears both in the type signature and as
          an extra argument in the validator definition, giving you a clear scaffold to plug your own parameter logic
          into.
        </p>
      </section>

      <!-- 9 -->
      <section id="section-9">
        <h2>9. üß™ Creating a Custom Smart Contract Industry</h2>
        <p>
          When you need a contract that is not well represented by any of the existing industries, you can switch into
          custom mode using the ‚ÄúCreate Custom Smart Contract‚Äù toggle in the top row. Once enabled, the standard datum
          and redeemer panels are hidden, the industry search and dropdown are disabled and a new ‚ÄúCustom Contract
          Title‚Äù section appears. Here you specify the contract‚Äôs title for the user interface, the internal module
          name, as well as explicit names for the datum and redeemer types that will appear in your Haskell code.
        </p>
        <p>
          To define your custom datum, you use the ‚ÄúCustom Datum‚Äù column in the custom row. You add as many fields as
          you need, each with a field name and a Plutus type selected from the shared type dropdown. These entries are
          converted directly into datum fields with labels, so that your generated module can show meaningful comments
          and field descriptions. For actions, the ‚ÄúCustom Redeemer‚Äù column allows you to define each action‚Äôs
          identifier and an optional human-readable label. When you click ‚ÄúGenerate Logic Spec‚Äù, CHPB validates that at
          least one datum field and one action have been defined. If not, it displays a clear alert and cancels the
          generation to prevent malformed specifications.
        </p>
        <p>
          Internally, CHPB assembles a synthetic industry object from the custom inputs, marking it as custom so that
          downstream functions know to use the custom fields and actions directly rather than relying on template
          checkboxes or constraint lists. This means that the rest of the pipeline, from building JSON to generating
          Haskell code, works identically whether you are using a template industry or a custom one. This unified
          pipeline keeps the tool predictable and easy to maintain.
        </p>
      </section>

      <!-- 10 -->
      <section id="section-10">
        <h2>10. ‚öôÔ∏è Generating JSON Specifications and Haskell Code</h2>
        <p>
          Once you are satisfied with your datum, redeemer and optional parameter configuration, you click the
          ‚ÄúGenerate Logic Spec‚Äù button located beneath the preview panel. When this button is pressed, CHPB assembles
          the current industry, whether template-based or custom, builds a datum specification, a parameter datum
          specification if requested and a redeemer specification, and then serialises them to JSON and Haskell code.
        </p>
        <p>
          For the datum JSON, the tool constructs a single object that includes the datum type name, the list of fields
          defined from template and custom entries and, when applicable, an embedded parameter datum section. Likewise,
          the redeemer JSON includes the redeemer type name, a list of actions each with their chosen constraints and an
          optional list that records any advanced additional actions you defined via the custom redeemer interface.
          These JSON outputs are useful for generating documentation, driving other tools or storing structured
          specifications for your contracts.
        </p>
        <p>
          At the same time, CHPB creates a concise ‚ÄúHaskell mkValidator Preview‚Äù and a full ‚ÄúHaskell Plutus Module‚Äù.
          The preview focuses on the type signature and the pattern matching over redeemer actions, making it easy to
          see at a glance how your selected constraints will be turned into checks. The full module extends this preview
          by including data type declarations for the datum, parameter datum and redeemer, utility imports and
          placeholder constraint function stubs corresponding to each constraint identifier in your industry.
        </p>
      </section>

      <!-- 11 -->
      <section id="section-11">
        <h2>11. üìÇ Downloading and Integrating ValidatorLogic.hs</h2>
        <p>
          The last row of the CHPB interface contains a large ‚ÄúFull Haskell Plutus Module‚Äù text area and a ‚ÄúDownload
          ValidatorLogic.hs‚Äù button. After generating the logic specification, the full module text area is populated
          with the complete Haskell source for your contract‚Äôs validator logic. At this point, you have two options. You
          may copy and paste the contents into your existing Haskell project manually, or you can click the download
          button to save the file directly as ValidatorLogic.hs.
        </p>
        <p>
          When you click the download button, CHPB verifies that the full output is present and, if necessary, reminds
          you to click ‚ÄúGenerate Logic Spec‚Äù first. It then creates a downloadable file with the Haskell content and
          triggers the download in your browser. In your local project, this module can now be compiled with your Plutus
          or Cardano infrastructure as you normally would, allowing you to move seamlessly from user interface driven
          design to on-chain deployment.
        </p>
      </section>

      <!-- 12 -->
      <section id="section-12">
        <h2>12. üß∑ End-to-End Example: Coxy / Marketplace Escrow</h2>
        <p>
          To illustrate the workflow, consider building a simple marketplace escrow where the buyer locks funds and the
          seller receives payment once certain conditions are met. You start by typing an appropriate search term into
          the search box or selecting a marketplace industry from the industry dropdown. The datum panel now shows
          fields such as seller, buyer, amount, deadline and possibly token-level information that can describe the
          asset being traded.
        </p>
        <p>
          For a straightforward escrow, you might select the seller, buyer, amount and deadline fields while omitting
          more advanced token-level fields if you are only handling the base currency. In the redeemer panel, you will
          see actions that correspond to paying the seller and refunding the buyer, each with its associated constraints.
          For the payment action, you keep constraints checked that ensure the payment is authorised by the buyer and
          that the correct script UTxO is being spent. For the refund action, you keep constraints checked that ensure
          that the refund occurs only under agreed conditions such as after a deadline or with the seller‚Äôs
          participation.
        </p>
        <p>
          If your protocol also requires an additional audit key, you can enable custom datum fields and add an extra
          public key hash field in the custom datum section. Once you are satisfied with these selections, you click
          ‚ÄúGenerate Logic Spec‚Äù. The datum JSON now describes a datum type containing your chosen fields and the extra
          audit field, the redeemer JSON describes the constraints bound to each action and the Haskell preview shows
          the validator branching on each action with the appropriate checks. You can then review the full module,
          download ValidatorLogic.hs and integrate it into your real Plutus project, adjusting the bodies of the
          constraint functions to match your precise validation logic and ledger operations.
        </p>
      </section>

      <!-- 13 -->
      <section id="section-13">
        <h2>13. üõ†Ô∏è Troubleshooting and Practical Tips</h2>
        <p>
          If you switch between industries or between template and custom modes and notice that your outputs no longer
          match your configuration, remember that CHPB purposely clears the JSON and Haskell outputs every time the
          selected industry or mode changes. This behaviour is by design and ensures that you never accidentally deploy
          code that was generated for a different configuration. Simply review your selections and click ‚ÄúGenerate Logic
          Spec‚Äù again to refresh the outputs.
        </p>
        <p>
          If search returns no industries for the term you entered, the dropdown will show that there are no results and
          the datum and action panels will be cleared. In that case, either adjust your search term or remove it
          entirely to restore the full list. When defining parameter datum fields or custom industries, always check
          that you have at least one field and, for custom industries, at least one action defined. Otherwise, CHPB will
          show an alert and abort the generation to protect you from producing unusable specifications.
        </p>
        <p>
          Finally, if clicking ‚ÄúDownload ValidatorLogic.hs‚Äù does nothing, it usually means that you have not yet
          generated the logic specification in the current session, or that the full module output has been cleared by
          mode changes. Click ‚ÄúGenerate Logic Spec‚Äù once more to fill the Haskell module area and then repeat the
          download step. Following these small checks and habits will help keep your workflow smooth and predictable.
        </p>
      </section>

      <hr class="divider" />

      <!-- 14 -->
      <section id="section-14">
        <h2>14. üìö Glossary of Terms</h2>

        <p class="glossary-term">Industry</p>
        <p>
          An industry is a reusable smart contract archetype defined within CHPB. It encapsulates a use case such as a
          marketplace, auction, automated market maker, decentralised organisation or credit primitive, and specifies
          the datum type, redeemer type, list of datum fields, actions and default constraints for that use case.
        </p>

        <p class="glossary-term">Datum</p>
        <p>
          A datum is the on-chain data record associated with a particular contract instance. CHPB models the datum as a
          Haskell data type with named fields, such as a seller public key hash or a deadline. These fields are exposed
          in the user interface as checkboxes and custom entries, and only the fields you select or define become part
          of the generated datum specification and Haskell type.
        </p>

        <p class="glossary-term">Redeemer</p>
        <p>
          A redeemer represents the action or intent of a transaction that interacts with the contract. In CHPB,
          redeemers are grouped into a type and are rendered as individual action blocks in the ‚ÄúCoxy Redeemer‚Äù panel.
          Each action, such as paying a seller or joining a membership programme, may carry its own set of constraints
          that describe what must hold true when that action is used.
        </p>

        <p class="glossary-term">Constraint</p>
        <p>
          A constraint is a named logical requirement that should be enforced by the validator for a given action.
          Examples include verifying that a transaction is signed by a specific party, ensuring that a script holds a
          particular token or enforcing that a price or liquidity condition is satisfied. Constraints are configured per
          action via checkboxes in the user interface and then turned into checks in the generated Haskell code.
        </p>

        <p class="glossary-term">CoxyParamDatum (Parameter Datum)</p>
        <p>
          CoxyParamDatum is an optional parameter-level datum type that models configuration parameters which are fixed
          for a script instance, such as fee schedules or governance addresses. When enabled, it appears as an extra
          argument in the validator type and is defined through its own list of fields in the parameter datum section.
          The tool requires at least one field to be defined for the parameter datum to avoid generating an empty or
          inconsistent type.
        </p>

        <p class="glossary-term">Custom Industry</p>
        <p>
          A custom industry is a contract definition you build yourself in CHPB by specifying the contract title,
          industry identifier, datum type, redeemer type, datum fields and actions. It is created when the ‚ÄúCreate
          Custom Smart Contract‚Äù toggle is enabled and is treated specially by the generation pipeline, which uses its
          custom fields and actions directly while still producing fully compatible JSON and Haskell outputs.
        </p>

        <p class="glossary-term">Generate Logic Spec</p>
        <p>
          ‚ÄúGenerate Logic Spec‚Äù is the primary action button that compiles your selections into a coherent
          specification. When clicked, it reads the current industry, builds datum, parameter datum and redeemer
          specifications and fills the Datum JSON, Redeemer JSON, Haskell validator preview and full Haskell Plutus
          module outputs. It ensures that any mode or industry changes are reflected consistently in the generated
          artefacts.
        </p>

        <p class="glossary-term">ValidatorLogic.hs</p>
        <p>
          ValidatorLogic.hs is the name of the downloadable Haskell file generated by CHPB. It contains the validator
          type signature, data type declarations, pattern matching skeleton over redeemer actions and placeholder calls
          to named constraint functions. This file is intended to be integrated into your Plutus or Cardano project
          where you implement the actual constraint logic and compile the module into an on-chain script.
        </p>
      </section>
    </main>
  </div>
</body>
</html>
